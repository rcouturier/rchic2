name: Build Portable Folder (All Platforms)

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create a GitHub release'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write

jobs:
  # ============================================================================
  # Linux Build
  # ============================================================================
  build-linux:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: electron/package-lock.json

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4.2'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libcurl4-openssl-dev libssl-dev libxml2-dev libsodium-dev libicu-dev

      - name: Install R packages
        run: |
          install.packages(c('plumber', 'jsonlite', 'promises', 'future', 'later',
                             'httpuv', 'webutils', 'swagger', 'magrittr', 'crayon',
                             'ellipsis', 'lifecycle', 'rlang', 'R6', 'stringi',
                             'sodium', 'digest', 'globals', 'listenv', 'parallelly', 'Rcpp',
                             'stringr'),
                           repos = 'https://cloud.r-project.org',
                           dependencies = c('Depends', 'Imports', 'LinkingTo'))
        shell: Rscript {0}

      - name: Prepare R Portable for Linux
        run: |
          OUTPUT_DIR="electron/R-portable-linux"
          R_HOME=$(R RHOME)

          echo "R_HOME: $R_HOME"

          # Create output directory and copy R
          mkdir -p "$OUTPUT_DIR"
          cp -R "$R_HOME"/* "$OUTPUT_DIR/"

          # Create bin directory with executables
          mkdir -p "$OUTPUT_DIR/bin"
          cp "$R_HOME/bin/R" "$OUTPUT_DIR/bin/" 2>/dev/null || true
          cp "$R_HOME/bin/Rscript" "$OUTPUT_DIR/bin/" 2>/dev/null || true
          chmod +x "$OUTPUT_DIR/bin/R" 2>/dev/null || true
          chmod +x "$OUTPUT_DIR/bin/Rscript" 2>/dev/null || true

          # Copy installed packages from R_LIBS_USER to R portable
          if [ -d "$R_LIBS_USER" ]; then
            echo "Copying packages from $R_LIBS_USER to $OUTPUT_DIR/library"
            cp -R "$R_LIBS_USER"/* "$OUTPUT_DIR/library/" 2>/dev/null || true
          fi

          echo "R Portable prepared at $OUTPUT_DIR"
          ls -la "$OUTPUT_DIR/library" | head -30

      - name: Install rchic package from source
        run: |
          R CMD INSTALL --library=electron/R-portable-linux/library .

      - name: Remove docs, translations and strip binaries for Linux
        run: |
          RD="electron/R-portable-linux"

          echo "Size before cleanup: $(du -sh "$RD" | cut -f1)"

          # Remove C headers (not needed at runtime)
          find "$RD" -maxdepth 5 -type d -name "include" | xargs rm -rf

          # Remove R documentation
          find "$RD" -maxdepth 5 -type d -name "doc" | xargs rm -rf

          # Remove per-package docs/tests/translations
          find "$RD" -path "*/library/*/html"      -type d | xargs rm -rf
          find "$RD" -path "*/library/*/tests"     -type d | xargs rm -rf
          find "$RD" -path "*/library/*/demo"      -type d | xargs rm -rf
          find "$RD" -path "*/library/*/vignettes" -type d | xargs rm -rf
          find "$RD" -path "*/library/*/po"        -type d | xargs rm -rf
          find "$RD" -path "*/library/*/tinytest"  -type d | xargs rm -rf
          find "$RD" -path "*/library/*/unitTests" -type d | xargs rm -rf
          find "$RD" -path "*/library/*/help"      -type d | xargs rm -rf
          find "$RD" -path "*/library/*/R/*.R"     -type f | xargs rm -f

          # Remove static libraries
          find "$RD" -name "*.a" -type f | xargs rm -f

          # Remove share/ subdirectories not needed at runtime
          find "$RD" -maxdepth 5 -path "*/share/locale" -type d | xargs rm -rf
          find "$RD" -maxdepth 5 -path "*/share/man"    -type d | xargs rm -rf
          find "$RD" -maxdepth 5 -path "*/share/doc"    -type d | xargs rm -rf
          find "$RD" -maxdepth 5 -path "*/share/info"   -type d | xargs rm -rf

          # Strip debug symbols
          find "$RD" -name "*.so"  -type f | while read f; do strip --strip-debug "$f" 2>/dev/null || true; done
          find "$RD" -name "*.so.*" -type f | while read f; do strip --strip-debug "$f" 2>/dev/null || true; done

          echo "Size after cleanup: $(du -sh "$RD" | cut -f1)"

      - name: Verify R installation
        run: |
          export R_HOME="electron/R-portable-linux"
          Rscript -e ".libPaths('electron/R-portable-linux/library'); library(plumber); cat('plumber OK\n'); library(rchic); cat('rchic OK\n')"

      - name: Install npm dependencies
        run: |
          cd electron
          npm ci

      - name: Build Linux portable folder
        run: |
          cd electron
          npm run build:linux-portable-folder
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Smoke test — R server startup (Linux)
        run: |
          PORT=18484
          DIST="electron/dist-portable-folder/linux-unpacked"
          RSCRIPT="$DIST/resources/R-portable/bin/Rscript"
          PLUMBER_DIR="$DIST/resources/plumber"
          WEB_DIR="$DIST/resources/web"

          if [ ! -f "$RSCRIPT" ]; then
            echo "ERROR: Rscript not found at $RSCRIPT"
            find "$DIST/resources" -name "Rscript" 2>/dev/null | head -10 || true
            exit 1
          fi
          chmod +x "$RSCRIPT"

          # Use R_LIBS (not R_HOME) — the bundled Rscript binary has R_HOME compiled-in and
          # prints "WARNING: ignoring environment value of R_HOME" when overridden.
          # R always respects R_LIBS and adds it to .libPaths() at startup.
          export R_LIBS="$DIST/resources/R-portable/library"

          echo "Starting R server on port $PORT..."
          "$RSCRIPT" "$PLUMBER_DIR/start-server.R" "$PORT" "$PLUMBER_DIR" "$WEB_DIR" \
            > /tmp/r-smoke.log 2>&1 &
          R_PID=$!
          echo "R PID: $R_PID"

          echo "Polling /api/health (up to 120 s, 2 s interval)..."
          for i in $(seq 1 60); do
            sleep 2
            if ! kill -0 $R_PID 2>/dev/null; then
              echo "ERROR: R process died before server was ready"
              cat /tmp/r-smoke.log
              exit 1
            fi
            if curl -sf "http://127.0.0.1:$PORT/api/health" > /dev/null; then
              echo "OK — server healthy after $((i * 2)) s"
              kill $R_PID 2>/dev/null || true
              exit 0
            fi
            echo "  attempt $i/60 ($((i * 2)) s elapsed)..."
          done

          echo "ERROR: server did not respond within 120 s"
          cat /tmp/r-smoke.log
          kill $R_PID 2>/dev/null || true
          exit 1

      - name: Rename and create ZIP archive
        run: |
          cd electron/dist-portable-folder
          mv linux-unpacked Rchic2-Linux
          zip -r Rchic2-Portable-Linux.zip Rchic2-Linux

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: Rchic2-Portable-Linux
          path: electron/dist-portable-folder/Rchic2-Portable-Linux.zip
          retention-days: 30

  # ============================================================================
  # macOS Build (Intel + ARM)
  # ============================================================================
  build-macos:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: macos-15-intel
            arch: x64
            arch-name: Intel
          - os: macos-latest
            arch: arm64
            arch-name: ARM

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: electron/package-lock.json

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4.2'

      - name: Install R packages
        run: |
          install.packages(c('plumber', 'jsonlite', 'promises', 'future', 'later',
                             'httpuv', 'webutils', 'swagger', 'magrittr', 'crayon',
                             'ellipsis', 'lifecycle', 'rlang', 'R6', 'stringi',
                             'sodium', 'digest', 'globals', 'listenv', 'parallelly', 'Rcpp',
                             'stringr'),
                           repos = 'https://cloud.r-project.org',
                           dependencies = c('Depends', 'Imports', 'LinkingTo'))
        shell: Rscript {0}

      - name: Prepare R Portable for macOS
        run: |
          OUTPUT_DIR="electron/R-portable-mac"

          # Find R.framework
          if [ -d "/Library/Frameworks/R.framework" ]; then
            R_FRAMEWORK="/Library/Frameworks/R.framework"
          elif [ -d "/opt/homebrew/Cellar/r" ]; then
            R_FRAMEWORK=$(find /opt/homebrew/Cellar/r -name "R.framework" -type d | head -1)
          elif [ -d "/usr/local/Cellar/r" ]; then
            R_FRAMEWORK=$(find /usr/local/Cellar/r -name "R.framework" -type d | head -1)
          fi

          echo "R.framework found at: $R_FRAMEWORK"

          # Create output directory
          mkdir -p "$OUTPUT_DIR"

          # Copy R.framework
          cp -R "$R_FRAMEWORK" "$OUTPUT_DIR/"

          # ── Prune unwanted R framework versions ──────────────────────────
          # The runner may have a pre-installed R version (e.g. 4.5-x86_64)
          # in addition to the one installed by setup-r (e.g. 4.4-arm64).
          # Keeping both causes ABI mismatches: packages compiled by setup-r's
          # R fail to load in the other R.  Keep only the version that matches.
          ARCH_SUFFIX_CLEAN="${{ matrix.arch == 'arm64' && 'arm64' || 'x86_64' }}"
          R_VER_MAJOR=$(Rscript --vanilla -e "cat(R.version[['major']])")
          R_VER_MINOR=$(Rscript --vanilla -e "cat(strsplit(R.version[['minor']], '.', fixed=TRUE)[[1]][1])")
          KEEP_FWVER="${R_VER_MAJOR}.${R_VER_MINOR}-${ARCH_SUFFIX_CLEAN}"
          echo "Pruning R.framework: keeping only '$KEEP_FWVER'"
          for vdir in "$OUTPUT_DIR/R.framework/Versions"/*/; do
            vname=$(basename "${vdir%/}")
            if [[ "$vname" == "Current" ]] || [ -L "${vdir%/}" ]; then continue; fi
            if [[ "$vname" != "$KEEP_FWVER" ]]; then
              echo "  Removing: $vname"
              rm -rf "${vdir%/}"
            else
              echo "  Keeping:  $vname"
            fi
          done
          # Update the Current symlink to point to the kept version
          rm -f "$OUTPUT_DIR/R.framework/Versions/Current"
          ln -sf "$KEEP_FWVER" "$OUTPUT_DIR/R.framework/Versions/Current"
          echo "R.framework/Versions/Current -> $KEEP_FWVER"

          # Create bin directory with wrapper scripts
          mkdir -p "$OUTPUT_DIR/bin"

          # Create Rscript wrapper using echo to avoid YAML heredoc issues
          # IMPORTANT: On macOS, bin/Rscript is a binary with hardcoded paths
          # We use the R shell script (which we patch) with --slave --no-restore instead
          {
            echo '#!/bin/bash'
            echo '# Rscript wrapper for portable R on macOS'
            echo ''
            echo '# Enable debug logging to /tmp/rscript-wrapper.log'
            echo 'exec 2>>/tmp/rscript-wrapper.log'
            echo 'echo "=== Rscript wrapper called at $(date) ===" >&2'
            echo 'echo "Args: $@" >&2'
            echo ''
            echo '# Get the directory of this script'
            echo 'SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"'
            echo 'echo "SCRIPT_DIR: $SCRIPT_DIR" >&2'
            echo ''
            echo '# Find R_HOME - check multiple possible locations'
            echo 'R_FRAMEWORK="$SCRIPT_DIR/../R.framework"'
            echo 'echo "R_FRAMEWORK: $R_FRAMEWORK" >&2'
            echo ''
            echo '# Try Resources symlink first'
            echo 'if [ -d "$R_FRAMEWORK/Resources/bin" ]; then'
            echo '  R_HOME="$R_FRAMEWORK/Resources"'
            echo '  echo "Found R_HOME via Resources symlink" >&2'
            echo 'else'
            echo '  # Try to find in Versions directory'
            echo '  for ver in "$R_FRAMEWORK/Versions"/*; do'
            echo '    if [ -d "$ver/Resources/bin" ]; then'
            echo '      R_HOME="$ver/Resources"'
            echo '      echo "Found R_HOME in Versions: $ver" >&2'
            echo '      break'
            echo '    fi'
            echo '  done'
            echo 'fi'
            echo ''
            echo 'echo "R_HOME: $R_HOME" >&2'
            echo ''
            echo '# Verify R_HOME'
            echo 'if [ -z "$R_HOME" ] || [ ! -d "$R_HOME/bin" ]; then'
            echo '  echo "ERROR: Cannot find R_HOME with valid bin directory" >&2'
            echo '  echo "Listing R.framework contents:" >&2'
            echo '  ls -la "$R_FRAMEWORK" >&2 2>/dev/null || echo "Cannot list R.framework" >&2'
            echo '  exit 1'
            echo 'fi'
            echo ''
            echo '# Check for R binary'
            echo 'R_BIN="$R_HOME/bin/R"'
            echo 'if [ ! -f "$R_BIN" ]; then'
            echo '  echo "ERROR: R binary not found at $R_BIN" >&2'
            echo '  echo "Contents of $R_HOME/bin:" >&2'
            echo '  ls -la "$R_HOME/bin" >&2 2>/dev/null'
            echo '  exit 1'
            echo 'fi'
            echo ''
            echo 'export R_HOME'
            echo 'export DYLD_LIBRARY_PATH="$R_HOME/lib:${DYLD_LIBRARY_PATH:-}"'
            echo ''
            echo 'echo "Executing: $R_BIN --slave --no-restore $@" >&2'
            echo 'exec "$R_BIN" --slave --no-restore "$@"'
          } > "$OUTPUT_DIR/bin/Rscript"
          chmod +x "$OUTPUT_DIR/bin/Rscript"

          # CRITICAL: Convert all absolute symlinks in R.framework to relative symlinks
          # This is essential for App Translocation to work on macOS
          echo "Converting absolute symlinks to relative in R.framework..."
          find "$OUTPUT_DIR/R.framework" -type l | while read -r link; do
            target=$(readlink "$link")
            # Check if the symlink is absolute
            if [[ "$target" == /* ]]; then
              # Check if the target exists within our R.framework
              link_dir=$(dirname "$link")
              # Try to find the target within our copied framework
              target_basename=$(basename "$target")
              target_dirname=$(dirname "$target")

              # If target contains R.framework, try to make it relative
              if [[ "$target" == *"R.framework"* ]]; then
                # Extract the part after R.framework
                after_framework=${target#*R.framework}
                new_target="$OUTPUT_DIR/R.framework$after_framework"
                if [ -e "$new_target" ]; then
                  # Calculate relative path from link location to new target
                  rel_target=$(realpath --relative-to="$link_dir" "$new_target" 2>/dev/null || python3 -c "import os.path; print(os.path.relpath('$new_target', '$link_dir'))")
                  echo "  Converting: $link"
                  echo "    From: $target"
                  echo "    To: $rel_target"
                  rm "$link"
                  ln -s "$rel_target" "$link"
                else
                  echo "  WARNING: Cannot convert $link - target $new_target does not exist"
                fi
              else
                echo "  WARNING: Absolute symlink outside R.framework: $link -> $target"
              fi
            fi
          done

          # Ensure Resources symlink exists and is correct
          echo "Checking R.framework structure..."
          ls -la "$OUTPUT_DIR/R.framework/"

          if [ ! -e "$OUTPUT_DIR/R.framework/Resources" ]; then
            echo "Resources symlink missing, creating it..."
            ACTUAL_RESOURCES=$(find "$OUTPUT_DIR/R.framework/Versions" -maxdepth 2 -type d -name "Resources" | head -1)
            if [ -n "$ACTUAL_RESOURCES" ]; then
              # Get relative path from R.framework to the actual Resources
              REL_PATH=$(realpath --relative-to="$OUTPUT_DIR/R.framework" "$ACTUAL_RESOURCES")
              ln -sf "$REL_PATH" "$OUTPUT_DIR/R.framework/Resources"
              echo "Created symlink: Resources -> $REL_PATH"
            fi
          fi

          # Verify symlinks are now relative
          echo "Verifying symlinks are relative..."
          find "$OUTPUT_DIR/R.framework" -type l | while read -r link; do
            target=$(readlink "$link")
            if [[ "$target" == /* ]]; then
              echo "  STILL ABSOLUTE: $link -> $target"
            fi
          done | head -20

          # Verify the Rscript binary exists
          echo "Verifying Rscript binaries..."
          if [ -x "$OUTPUT_DIR/R.framework/Resources/bin/Rscript" ]; then
            echo "Found: $OUTPUT_DIR/R.framework/Resources/bin/Rscript"
          else
            echo "WARNING: $OUTPUT_DIR/R.framework/Resources/bin/Rscript not found or not executable!"
            find "$OUTPUT_DIR/R.framework" -name "Rscript" -type f 2>/dev/null || true
          fi

          # Make sure all binaries are executable
          find "$OUTPUT_DIR/R.framework" -name "Rscript" -type f -exec chmod +x {} \;
          find "$OUTPUT_DIR/R.framework" -name "R" -type f -exec chmod +x {} \;

          # CRITICAL: Patch R and Rscript scripts in ALL R.framework versions
          # Each version (e.g. 4.4-arm64, 4.5-x86_64) has its own bin/R with hardcoded paths
          echo "Patching R scripts to use dynamic paths..."

          # Create the dynamic R_HOME detection code as a separate file
          {
            echo '# Dynamic R_HOME detection - patched for portable deployment'
            echo 'SCRIPT_PATH="$0"'
            echo 'while [ -L "${SCRIPT_PATH}" ]; do'
            echo '  SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"'
            echo '  SCRIPT_PATH="$(readlink "${SCRIPT_PATH}")"'
            echo '  case "${SCRIPT_PATH}" in /*) ;; *) SCRIPT_PATH="${SCRIPT_DIR}/${SCRIPT_PATH}" ;; esac'
            echo 'done'
            echo 'SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"'
            echo 'R_HOME_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"'
          } > /tmp/r_home_detect.sh

          # Patch a single script file: replace the R_HOME_DIR= line with dynamic detection
          patch_r_script() {
            local SCRIPT_FILE="$1"
            if [ ! -f "$SCRIPT_FILE" ]; then
              return
            fi
            echo "Patching $SCRIPT_FILE"
            grep "^R_HOME_DIR=" "$SCRIPT_FILE" | head -1 || true

            LINE_NUM=$(grep -n "^R_HOME_DIR=" "$SCRIPT_FILE" | head -1 | cut -d: -f1)
            if [ -n "$LINE_NUM" ]; then
              {
                head -n $((LINE_NUM - 1)) "$SCRIPT_FILE"
                cat /tmp/r_home_detect.sh
                tail -n +$((LINE_NUM + 1)) "$SCRIPT_FILE"
              } > "${SCRIPT_FILE}.patched"
              mv "${SCRIPT_FILE}.patched" "$SCRIPT_FILE"
              chmod +x "$SCRIPT_FILE"
              echo "  Patched successfully (replaced line $LINE_NUM)"
            else
              echo "  Skipped: no R_HOME_DIR= line found (already patched?)"
            fi
          }

          # Loop over ALL Resources directories in R.framework/Versions
          find "$OUTPUT_DIR/R.framework/Versions" -maxdepth 2 -type d -name "Resources" | while read -r RESOURCES_DIR; do
            echo "--- Processing: $RESOURCES_DIR ---"
            patch_r_script "$RESOURCES_DIR/bin/R"
            patch_r_script "$RESOURCES_DIR/bin/Rscript"
          done

          rm -f /tmp/r_home_detect.sh
          echo "All R scripts patched"

          # Verify the patched scripts for each version
          find "$OUTPUT_DIR/R.framework/Versions" -maxdepth 2 -type d -name "Resources" | while read -r RESOURCES_DIR; do
            echo "=== Verifying $RESOURCES_DIR/bin/R (first 20 lines) ==="
            head -20 "$RESOURCES_DIR/bin/R" || true
          done

          # Find library path matching the runner architecture
          ARCH_SUFFIX="${{ matrix.arch == 'arm64' && 'arm64' || 'x86_64' }}"
          ACTUAL_LIB=$(find "$OUTPUT_DIR/R.framework/Versions" -maxdepth 3 -type d -name "library" -path "*${ARCH_SUFFIX}*" | head -1)
          if [ -z "$ACTUAL_LIB" ]; then
            # Fallback: any library
            ACTUAL_LIB=$(find "$OUTPUT_DIR/R.framework/Versions" -maxdepth 3 -type d -name "library" | head -1)
          fi
          echo "Target library ($ARCH_SUFFIX): $ACTUAL_LIB"

          if [ -d "$R_LIBS_USER" ]; then
            echo "Copying packages from $R_LIBS_USER to $ACTUAL_LIB"
            cp -R "$R_LIBS_USER"/* "$ACTUAL_LIB/" 2>/dev/null || true
          fi

          echo "R Portable prepared at $OUTPUT_DIR"
          ls -la "$ACTUAL_LIB" | head -30

      - name: Remove headers, docs and strip binaries from R.framework
        run: |
          FW="electron/R-portable-mac/R.framework"

          echo "Size before cleanup: $(du -sh "$FW" | cut -f1)"

          # Remove C headers (not needed at runtime)
          find "$FW" -maxdepth 5 -type d -name "include" | xargs rm -rf

          # Remove R documentation directory
          find "$FW" -maxdepth 5 -type d -name "doc" | xargs rm -rf

          # Remove per-package HTML docs, tests, demos, help sources
          find "$FW" -path "*/library/*/html"      -type d | xargs rm -rf
          find "$FW" -path "*/library/*/tests"     -type d | xargs rm -rf
          find "$FW" -path "*/library/*/demo"      -type d | xargs rm -rf
          find "$FW" -path "*/library/*/vignettes" -type d | xargs rm -rf
          find "$FW" -path "*/library/*/po"        -type d | xargs rm -rf
          find "$FW" -path "*/library/*/tinytest"  -type d | xargs rm -rf
          find "$FW" -path "*/library/*/unitTests" -type d | xargs rm -rf

          # Remove compiled help databases (not needed at runtime)
          find "$FW" -path "*/library/*/help" -type d | xargs rm -rf

          # Remove R source files kept alongside bytecode
          find "$FW" -path "*/library/*/R/*.R" -type f | xargs rm -f

          # Remove static libraries (not needed at runtime)
          find "$FW" -name "*.a" -type f | xargs rm -f

          # Remove share/ subdirectories that are not needed at runtime
          # (keep share/R/ which contains base R scripts used at startup)
          find "$FW" -maxdepth 6 -path "*/share/locale" -type d | xargs rm -rf
          find "$FW" -maxdepth 6 -path "*/share/man"    -type d | xargs rm -rf
          find "$FW" -maxdepth 6 -path "*/share/doc"    -type d | xargs rm -rf
          find "$FW" -maxdepth 6 -path "*/share/info"   -type d | xargs rm -rf

          # Strip debug symbols from all .dylib files
          find "$FW" -name "*.dylib" -type f | while read f; do
            strip -x "$f" 2>/dev/null || true
          done

          # Strip debug symbols from .so files (R package shared libs)
          find "$FW" -name "*.so" -type f | while read f; do
            strip -x "$f" 2>/dev/null || true
          done

          echo "Size after cleanup: $(du -sh "$FW" | cut -f1)"

      - name: Install rchic package from source
        run: |
          # Find library path matching the runner architecture.
          # After pruning in the Prepare step, only one version remains in the
          # bundle and it matches the setup-r version used to compile packages.
          ARCH_SUFFIX="${{ matrix.arch == 'arm64' && 'arm64' || 'x86_64' }}"
          LIB_PATH=$(find electron/R-portable-mac/R.framework/Versions -maxdepth 3 -type d -name "library" -path "*${ARCH_SUFFIX}*" | head -1)
          if [ -z "$LIB_PATH" ]; then
            LIB_PATH=$(find electron/R-portable-mac/R.framework/Versions -maxdepth 3 -type d -name "library" | head -1)
          fi
          echo "Installing rchic to ($ARCH_SUFFIX): $LIB_PATH"
          R CMD INSTALL --library="$LIB_PATH" .

      - name: Verify R installation
        run: |
          # Find library path matching the runner architecture
          ARCH_SUFFIX="${{ matrix.arch == 'arm64' && 'arm64' || 'x86_64' }}"
          LIB_PATH=$(find electron/R-portable-mac/R.framework -type d -name "library" -path "*${ARCH_SUFFIX}*" | head -1)
          echo "Using library path ($ARCH_SUFFIX): $LIB_PATH"
          electron/R-portable-mac/bin/Rscript -e ".libPaths('$LIB_PATH'); library(plumber); cat('plumber OK\n'); library(rchic); cat('rchic OK\n')"

      - name: Install npm dependencies
        run: |
          cd electron
          npm ci

      - name: Build macOS portable folder
        run: |
          cd electron
          npm run build:mac-portable-folder
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Smoke test — R server startup (macOS)
        run: |
          PORT=18484
          APP_PATH=$(find electron/dist-portable-folder -maxdepth 2 -name "*.app" -type d | head -1)
          RESOURCES="$APP_PATH/Contents/Resources"

          # Find R binary — prefer arch-matching version to avoid running x86_64
          # R on an arm64 runner (or vice versa) after pruning in the Prepare step.
          ARCH_SUFFIX_SMOKE="${{ matrix.arch == 'arm64' && 'arm64' || 'x86_64' }}"
          R_BIN=$(find "$RESOURCES/R-portable/R.framework/Versions" -path "*${ARCH_SUFFIX_SMOKE}*/bin/R" -type f | head -1)
          if [ -z "$R_BIN" ]; then
            R_BIN=$(find "$RESOURCES/R-portable/R.framework/Versions" -path "*/bin/R" -type f | head -1)
          fi
          if [ -z "$R_BIN" ]; then
            echo "ERROR: R binary not found under $RESOURCES/R-portable"
            find "$RESOURCES/R-portable" \( -name "R" -o -name "Rscript" \) 2>/dev/null | head -10 || true
            exit 1
          fi
          chmod +x "$R_BIN"

          PLUMBER_DIR="$RESOURCES/plumber"
          WEB_DIR="$RESOURCES/web"
          R_HOME="$(cd "$(dirname "$R_BIN")/.." && pwd)"
          export R_HOME

          echo "Starting R server (R: $R_BIN, R_HOME: $R_HOME, port: $PORT)..."
          "$R_BIN" --slave --no-restore \
            --file="$PLUMBER_DIR/start-server.R" \
            --args "$PORT" "$PLUMBER_DIR" "$WEB_DIR" \
            > /tmp/r-smoke.log 2>&1 &
          R_PID=$!
          echo "R PID: $R_PID"

          echo "Polling /api/health (up to 120 s, 2 s interval)..."
          for i in $(seq 1 60); do
            sleep 2
            if ! kill -0 $R_PID 2>/dev/null; then
              echo "ERROR: R process died before server was ready"
              cat /tmp/r-smoke.log
              exit 1
            fi
            if curl -sf "http://127.0.0.1:$PORT/api/health" > /dev/null; then
              echo "OK — server healthy after $((i * 2)) s"
              kill $R_PID 2>/dev/null || true
              exit 0
            fi
            echo "  attempt $i/60 ($((i * 2)) s elapsed)..."
          done

          echo "ERROR: server did not respond within 120 s"
          cat /tmp/r-smoke.log
          kill $R_PID 2>/dev/null || true
          exit 1

      - name: Rename and create ZIP archive
        run: |
          # Find the .app bundle
          APP_PATH=$(find electron/dist-portable-folder -maxdepth 2 -name "*.app" -type d | head -1)
          echo "Found app at: $APP_PATH"

          # Create directory with appropriate name based on architecture
          ARCH_NAME="${{ matrix.arch-name }}"
          FOLDER_NAME="Rchic2-macOS-${ARCH_NAME}"
          mkdir -p "electron/dist-portable-folder/${FOLDER_NAME}"

          # Move .app into the named folder
          mv "$APP_PATH" "electron/dist-portable-folder/${FOLDER_NAME}/"

          # Create ZIP archive
          cd electron/dist-portable-folder
          zip -r "Rchic2-Portable-macOS-${ARCH_NAME}.zip" "${FOLDER_NAME}"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: Rchic2-Portable-macOS-${{ matrix.arch-name }}
          path: electron/dist-portable-folder/Rchic2-Portable-macOS-${{ matrix.arch-name }}.zip
          retention-days: 30

  # ============================================================================
  # Windows Build
  # ============================================================================
  build-windows:
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: electron/package-lock.json

      - name: Setup R
        uses: r-lib/actions/setup-r@v2
        with:
          r-version: '4.4.2'

      - name: Install R packages
        run: |
          install.packages(c('plumber', 'jsonlite', 'promises', 'future', 'later',
                             'httpuv', 'webutils', 'swagger', 'magrittr', 'crayon',
                             'ellipsis', 'lifecycle', 'rlang', 'R6', 'stringi',
                             'sodium', 'digest', 'globals', 'listenv', 'parallelly', 'Rcpp',
                             'stringr'),
                           repos = 'https://cloud.r-project.org',
                           dependencies = c('Depends', 'Imports', 'LinkingTo'))
        shell: Rscript {0}

      - name: Prepare R Portable for Windows
        shell: pwsh
        run: |
          $OUTPUT_DIR = "electron/R-portable-win"
          $R_HOME = $env:R_HOME

          Write-Host "R_HOME: $R_HOME"

          if (-not $R_HOME -or -not (Test-Path $R_HOME)) {
            # Search for R installation
            $searchPaths = @("C:\R", "C:\Program Files\R", "$env:RUNNER_TOOL_CACHE\R")
            foreach ($basePath in $searchPaths) {
              if (Test-Path $basePath) {
                $rPaths = Get-ChildItem $basePath -Directory -ErrorAction SilentlyContinue |
                          Where-Object { $_.Name -match "^R-?\d" } |
                          Sort-Object Name -Descending
                if ($rPaths.Count -gt 0) {
                  $R_HOME = $rPaths[0].FullName
                  break
                }
              }
            }
          }

          if (-not $R_HOME -or -not (Test-Path $R_HOME)) {
            Write-Host "ERROR: R installation not found!"
            exit 1
          }

          Write-Host "Using R from: $R_HOME"

          # Create output directory and copy R
          New-Item -ItemType Directory -Path $OUTPUT_DIR -Force | Out-Null
          Copy-Item -Path "$R_HOME\*" -Destination $OUTPUT_DIR -Recurse -Force

          # Copy installed packages from R_LIBS_USER to R portable
          $R_LIBS_USER = $env:R_LIBS_USER
          if ($R_LIBS_USER -and (Test-Path $R_LIBS_USER)) {
            Write-Host "Copying packages from $R_LIBS_USER to $OUTPUT_DIR\library"
            Copy-Item -Path "$R_LIBS_USER\*" -Destination "$OUTPUT_DIR\library" -Recurse -Force -ErrorAction SilentlyContinue
          }

          Write-Host "R Portable prepared at $OUTPUT_DIR"
          Get-ChildItem "$OUTPUT_DIR\library" | Select-Object -First 30

      - name: Install rchic package from source
        shell: cmd
        run: R CMD INSTALL --library=electron/R-portable-win/library .

      - name: Verify R installation
        shell: pwsh
        run: |
          $rscript = "electron/R-portable-win/bin/Rscript.exe"
          if (!(Test-Path $rscript)) {
            $rscript = "electron/R-portable-win/bin/x64/Rscript.exe"
          }
          & $rscript -e "library(plumber); cat('plumber OK\n'); library(rchic); cat('rchic OK\n')"

      - name: Install npm dependencies
        run: |
          cd electron
          npm ci

      - name: Build Windows portable folder
        run: |
          cd electron
          npm run build:win-portable-folder
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Smoke test — R server startup (Windows)
        shell: pwsh
        run: |
          $PORT        = 18484
          $RESOURCES   = "electron\dist-portable-folder\win-unpacked\resources"
          $PLUMBER_DIR = "$RESOURCES\plumber"
          $WEB_DIR     = "$RESOURCES\web"
          $LOG         = "$env:TEMP\r-smoke.log"
          $LOG_ERR     = "$env:TEMP\r-smoke-err.log"

          # Prefer bin\x64\Rscript.exe — the actual binary.
          # bin\Rscript.exe is a launcher with hardcoded absolute paths and
          # will not work on any machine other than the original build host.
          $RSCRIPT = "$RESOURCES\R-portable\bin\x64\Rscript.exe"
          if (!(Test-Path $RSCRIPT)) {
            $RSCRIPT = "$RESOURCES\R-portable\bin\Rscript.exe"
          }
          if (!(Test-Path $RSCRIPT)) {
            Write-Host "ERROR: Rscript not found"
            Get-ChildItem "$RESOURCES\R-portable\bin" -Recurse -ErrorAction SilentlyContinue |
              Select-Object FullName
            exit 1
          }

          Write-Host "Starting R server on port $PORT..."
          Write-Host "Rscript: $RSCRIPT"
          $proc = Start-Process -FilePath $RSCRIPT `
            -ArgumentList "$PLUMBER_DIR\start-server.R", $PORT, $PLUMBER_DIR, $WEB_DIR `
            -RedirectStandardOutput $LOG -RedirectStandardError $LOG_ERR `
            -PassThru -NoNewWindow
          Write-Host "R PID: $($proc.Id)"

          Write-Host "Polling /api/health (up to 120 s, 2 s interval)..."
          $ok = $false
          for ($i = 1; $i -le 60; $i++) {
            Start-Sleep -Seconds 2
            if ($proc.HasExited) {
              Write-Host "ERROR: R process exited with code $($proc.ExitCode)"
              Get-Content $LOG     -ErrorAction SilentlyContinue
              Get-Content $LOG_ERR -ErrorAction SilentlyContinue
              exit 1
            }
            try {
              $resp = Invoke-WebRequest -Uri "http://127.0.0.1:$PORT/api/health" `
                -TimeoutSec 3 -UseBasicParsing -ErrorAction Stop
              if ($resp.StatusCode -eq 200) {
                Write-Host "OK — server healthy after $($i * 2) s"
                $ok = $true
                break
              }
            } catch {
              Write-Host "  attempt $i/60 ($($i * 2) s elapsed)..."
            }
          }

          Stop-Process -Id $proc.Id -Force -ErrorAction SilentlyContinue
          if (-not $ok) {
            Write-Host "ERROR: server did not respond within 120 s"
            Get-Content $LOG     -ErrorAction SilentlyContinue
            Get-Content $LOG_ERR -ErrorAction SilentlyContinue
            exit 1
          }

      - name: Rename and create ZIP archive
        shell: pwsh
        run: |
          cd electron/dist-portable-folder
          Rename-Item -Path win-unpacked -NewName Rchic2-Windows
          Compress-Archive -Path Rchic2-Windows -DestinationPath Rchic2-Portable-Windows.zip

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: Rchic2-Portable-Windows
          path: electron/dist-portable-folder/Rchic2-Portable-Windows.zip
          retention-days: 30

  # ============================================================================
  # Create Release (when all builds complete)
  # ============================================================================
  create-release:
    needs: [build-linux, build-macos, build-windows]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && github.event.inputs.create_release == 'true')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: List artifacts
        run: |
          echo "Downloaded artifacts:"
          find artifacts -type f -name "*.zip"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Rchic2 Portable ${{ github.ref_name }}
          body: |
            ## Rchic2 Portable Release

            Download the ZIP file for your platform, extract it, and run the application directly.
            No installation required - all dependencies (including R) are bundled.

            ### Downloads
            - **Linux**: `Rchic2-Portable-Linux.zip`
            - **macOS Intel**: `Rchic2-Portable-macOS-Intel.zip`
            - **macOS ARM (Apple Silicon)**: `Rchic2-Portable-macOS-ARM.zip`
            - **Windows**: `Rchic2-Portable-Windows.zip`

            ### How to use
            1. Download the ZIP for your platform
            2. Extract the archive
            3. Run the executable:
               - Linux: Navigate to the extracted folder and run `./Rchic2`
               - macOS: Navigate to the extracted folder, open `Rchic2.app`
               - Windows: Navigate to the extracted folder and run `Rchic2.exe`
          files: |
            artifacts/Rchic2-Portable-Linux/*.zip
            artifacts/Rchic2-Portable-macOS-Intel/*.zip
            artifacts/Rchic2-Portable-macOS-ARM/*.zip
            artifacts/Rchic2-Portable-Windows/*.zip
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
